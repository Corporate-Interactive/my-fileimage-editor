import _extends from "@babel/runtime/helpers/extends";
import _typeof from "@babel/runtime/helpers/typeof";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
var _excluded = ["MenuProps", "LabelProps", "InputProps", "error", "label", "hint", "noOptionsText", "focusOnOpen", "getOptionDisabled", "getOptionValue", "getOptionLabel", "multiple", "size", "disabled", "disableTextEllipse", "readOnly", "placeholder", "fullWidth", "maxMenuHeight", "showClearIcon", "renderLabelIconEnd", "renderOptionLabel", "renderSearchEmptyMenuItem", "renderGroup", "groupBy", "hideArrow", "renderTag", "renderMenuItem", "onChange", "selectAllButtonLabel", "clearAllButtonLabel", "onClearAll", "onSelectAll"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import React, { useEffect, useState } from 'react';
import Tick from '@scaleflex/icons/tick';
import { intrinsicComponent } from '../../utils/functions';
import Input from '../input';
import Tag from '../tag';
import MenuItem, { MenuItemActions } from '../menu-item';
import { InputSize } from '../../utils/types';
import Styled from './autocomplete.styles';
import { renderLabel, renderHint, defaultGetOptionValue, defaultGetOptionLabel } from './autocomplete.utils';
import { useAutocomplete } from './autocomplete.hook';
import TextWithHighlights from '../text-with-highlights';
import EllipsedText from '../ellipsed-text';
import Button from '../button/button.component';
var Autocomplete = intrinsicComponent(function (props, ref) {
  var _useState = useState(true),
    _useState2 = _slicedToArray(_useState, 2),
    menuJustOpened = _useState2[0],
    setMenuJustOpened = _useState2[1];
  var MenuProps = props.MenuProps,
    LabelPropsData = props.LabelProps,
    InputPropsData = props.InputProps,
    error = props.error,
    label = props.label,
    hint = props.hint,
    _props$noOptionsText = props.noOptionsText,
    noOptionsText = _props$noOptionsText === void 0 ? 'No options' : _props$noOptionsText,
    focusOnOpen = props.focusOnOpen,
    _props$getOptionDisab = props.getOptionDisabled,
    getOptionDisabled = _props$getOptionDisab === void 0 ? function () {
      return false;
    } : _props$getOptionDisab,
    _props$getOptionValue = props.getOptionValue,
    getOptionValue = _props$getOptionValue === void 0 ? defaultGetOptionValue : _props$getOptionValue,
    _props$getOptionLabel = props.getOptionLabel,
    getOptionLabel = _props$getOptionLabel === void 0 ? defaultGetOptionLabel : _props$getOptionLabel,
    _props$multiple = props.multiple,
    multiple = _props$multiple === void 0 ? false : _props$multiple,
    _props$size = props.size,
    size = _props$size === void 0 ? InputSize.Md : _props$size,
    _props$disabled = props.disabled,
    disabled = _props$disabled === void 0 ? false : _props$disabled,
    _props$disableTextEll = props.disableTextEllipse,
    disableTextEllipse = _props$disableTextEll === void 0 ? false : _props$disableTextEll,
    _props$readOnly = props.readOnly,
    readOnly = _props$readOnly === void 0 ? false : _props$readOnly,
    placeholder = props.placeholder,
    fullWidth = props.fullWidth,
    _props$maxMenuHeight = props.maxMenuHeight,
    maxMenuHeight = _props$maxMenuHeight === void 0 ? 250 : _props$maxMenuHeight,
    _props$showClearIcon = props.showClearIcon,
    showClearIcon = _props$showClearIcon === void 0 ? false : _props$showClearIcon,
    renderLabelIconEnd = props.renderLabelIconEnd,
    renderOptionLabel = props.renderOptionLabel,
    renderSearchEmptyMenuItem = props.renderSearchEmptyMenuItem,
    renderGroup = props.renderGroup,
    groupBy = props.groupBy,
    _props$hideArrow = props.hideArrow,
    hideArrow = _props$hideArrow === void 0 ? false : _props$hideArrow,
    renderTag = props.renderTag,
    renderMenuItemCustomFn = props.renderMenuItem,
    onChange = props.onChange,
    _props$selectAllButto = props.selectAllButtonLabel,
    selectAllButtonLabel = _props$selectAllButto === void 0 ? 'Select all' : _props$selectAllButto,
    _props$clearAllButton = props.clearAllButtonLabel,
    clearAllButtonLabel = _props$clearAllButton === void 0 ? 'Clear all' : _props$clearAllButton,
    onClearAll = props.onClearAll,
    onSelectAll = props.onSelectAll,
    rest = _objectWithoutProperties(props, _excluded);
  var _useAutocomplete = useAutocomplete(_objectSpread(_objectSpread({}, props), {}, {
      onChange: onChange,
      getOptionValue: getOptionValue,
      getOptionLabel: getOptionLabel,
      getOptionDisabled: getOptionDisabled,
      setMenuJustOpened: setMenuJustOpened
    })),
    formattedValue = _useAutocomplete.formattedValue,
    filteredOptions = _useAutocomplete.filteredOptions,
    groupedFilteredOptions = _useAutocomplete.groupedFilteredOptions,
    optionsList = _useAutocomplete.optionsList,
    inputRef = _useAutocomplete.inputRef,
    inputValue = _useAutocomplete.inputValue,
    isValueSelected = _useAutocomplete.isValueSelected,
    open = _useAutocomplete.open,
    anchorEl = _useAutocomplete.anchorEl,
    searchTerm = _useAutocomplete.searchTerm,
    handleMenuItemClick = _useAutocomplete.handleMenuItemClick,
    handleOpenMenuClick = _useAutocomplete.handleOpenMenuClick,
    handleChangeSearchTerm = _useAutocomplete.handleChangeSearchTerm,
    handleCloseMenuClick = _useAutocomplete.handleCloseMenuClick,
    handleOnRemoveItem = _useAutocomplete.handleOnRemoveItem,
    handleOnBlur = _useAutocomplete.handleOnBlur,
    handleKeyDown = _useAutocomplete.handleKeyDown,
    handleClearIconClick = _useAutocomplete.handleClearIconClick,
    checkIsIdSelected = _useAutocomplete.checkIsIdSelected,
    handleSelectAllOptions = _useAutocomplete.handleSelectAllOptions,
    getOptionById = _useAutocomplete.getOptionById,
    focusedMenuItemIndex = _useAutocomplete.focusedMenuItemIndex;
  var isMultiple = Boolean(multiple) && Array.isArray(formattedValue);
  var handleSelectAll = function handleSelectAll(event) {
    handleSelectAllOptions();
    event.stopPropagation();
    if (onSelectAll) {
      onSelectAll(event);
    }
  };
  var handleClearAll = function handleClearAll(event) {
    handleClearIconClick();
    event.stopPropagation();
    if (onClearAll) {
      onClearAll(event);
    }
  };
  useEffect(function () {
    setMenuJustOpened(open);
  }, [open]);
  var renderMenuItem = function renderMenuItem(option, index) {
    var optionId = getOptionValue(option);
    var optionLabel = getOptionLabel(option);
    var isActive = checkIsIdSelected(optionId);
    var isDisabled = getOptionDisabled(option);
    var label = renderOptionLabel ? renderOptionLabel(option) : /*#__PURE__*/React.createElement(TextWithHighlights, {
      highlightText: searchTerm,
      text: optionLabel
    });
    var isFocused = !menuJustOpened && index === focusedMenuItemIndex;
    var menuItemProps = {
      key: optionId,
      value: optionId,
      size: size,
      onMouseDown: function onMouseDown(event) {
        return event.preventDefault();
      },
      disabled: isDisabled,
      active: isActive,
      isFocused: isFocused,
      onClick: function onClick() {
        return handleMenuItemClick(option);
      },
      enableScrollIntoView: true,
      children: /*#__PURE__*/React.createElement(React.Fragment, null, disableTextEllipse ? label : /*#__PURE__*/React.createElement(EllipsedText, {
        maxLinesCount: 1
      }, label), isActive && !renderOptionLabel && /*#__PURE__*/React.createElement(MenuItemActions, null, /*#__PURE__*/React.createElement(Styled.TickIcon, null, /*#__PURE__*/React.createElement(Tick, {
        size: size === 'md' ? 16 : 14
      }))))
    };
    if (typeof renderMenuItemCustomFn === 'function') {
      var _option = getOptionById(optionId);
      return renderMenuItemCustomFn({
        id: optionId,
        label: label,
        option: _option,
        menuItemProps: menuItemProps
      });
    }
    return /*#__PURE__*/React.createElement(MenuItem, menuItemProps);
  };
  var renderTags = function renderTags() {
    return isMultiple && formattedValue.map(function (optionId, index) {
      var option = getOptionById(optionId);
      var optionLabel = option ? getOptionLabel(option) : optionId;
      if (typeof renderTag === 'function') {
        return renderTag({
          id: optionId,
          label: optionLabel,
          option: option,
          size: size,
          onRemove: function onRemove(event) {
            return handleOnRemoveItem(event, optionId);
          }
        });
      }
      return /*#__PURE__*/React.createElement(Tag, {
        key: optionId,
        tagIndex: index,
        crossIcon: true,
        onRemove: function onRemove(_, event) {
          return handleOnRemoveItem(event, optionId);
        },
        title: optionLabel,
        size: size
      }, optionLabel);
    });
  };
  var renderMenuContent = function renderMenuContent() {
    if (filteredOptions.length > 0) {
      if (groupBy) {
        return groupedFilteredOptions.map(function (_ref, index) {
          var groupOptions = _ref.options,
            groupedByValue = _ref.groupedByValue;
          var groupKey = ['string', 'number'].includes(_typeof(groupedByValue)) ? groupedByValue : index;
          var groupChildren = groupOptions.map(renderMenuItem);
          return renderGroup ? renderGroup({
            key: groupKey,
            group: groupedByValue,
            children: groupChildren
          }) : /*#__PURE__*/React.createElement(Styled.OptionGroup, {
            key: groupKey
          }, groupChildren);
        });
      }
      return filteredOptions.map(renderMenuItem);
    }
    if (optionsList.length > 0 && renderSearchEmptyMenuItem) {
      return renderSearchEmptyMenuItem();
    }
    return /*#__PURE__*/React.createElement(MenuItem, {
      disabled: Boolean(noOptionsText),
      size: size
    }, noOptionsText);
  };
  var renderInputEndIcons = function renderInputEndIcons() {
    return /*#__PURE__*/React.createElement(React.Fragment, null, renderLabelIconEnd && renderLabelIconEnd({
      isMultiple: isMultiple,
      option: !isMultiple && formattedValue && typeof formattedValue === 'string' ? getOptionById(formattedValue) : null
    }), !hideArrow && /*#__PURE__*/React.createElement(Styled.Arrow, _extends({}, !disabled && !readOnly ? {
      onClick: handleOpenMenuClick
    } : {}, {
      type: open ? 'top' : 'bottom',
      IconProps: {
        size: size === 'md' ? 11 : 10
      }
    })));
  };
  var renderInputActions = function renderInputActions() {
    return /*#__PURE__*/React.createElement(Styled.InputIconEndContainer, null, /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Button, {
      size: "sm",
      color: "link-basic-primary",
      onClick: handleSelectAll
    }, selectAllButtonLabel), /*#__PURE__*/React.createElement(Button, {
      color: "link-secondary",
      size: "sm",
      onClick: handleClearAll
    }, clearAllButtonLabel)), renderInputEndIcons());
  };
  return /*#__PURE__*/React.createElement(Styled.Autocomplete, _extends({
    ref: ref
  }, rest), renderLabel({
    label: label,
    error: error,
    size: size,
    LabelProps: LabelPropsData
  }), /*#__PURE__*/React.createElement(Styled.AutocompleteContainer, {
    onClick: disabled || readOnly ? undefined : handleOpenMenuClick
  }, /*#__PURE__*/React.createElement(Input, _extends({}, isMultiple ? {
    renderTags: renderTags,
    selectedItems: formattedValue
  } : {}, InputPropsData || {}, {
    ref: inputRef,
    size: size,
    value: inputValue,
    readOnly: readOnly,
    error: error,
    focusOnMount: focusOnOpen,
    onKeyDown: handleKeyDown,
    onChange: handleChangeSearchTerm,
    onBlur: handleOnBlur,
    disabled: disabled,
    placeholder: placeholder,
    fullWidth: fullWidth,
    isEllipsis: true,
    iconEnd: isMultiple ? undefined : renderInputEndIcons,
    inputActions: isMultiple ? renderInputActions() : undefined
  }, showClearIcon ? {
    clearIcon: isValueSelected && /*#__PURE__*/React.createElement(Styled.CrossIcon, {
      size: size === 'md' ? 11 : 10
    }),
    clearIconClick: handleClearIconClick
  } : {}))), /*#__PURE__*/React.createElement(Styled.Menu, _extends({
    onClose: handleCloseMenuClick,
    open: open,
    anchorEl: anchorEl,
    maxMenuHeight: maxMenuHeight
  }, MenuProps), renderMenuContent()), renderHint({
    hint: hint,
    error: error,
    size: size
  }));
});
export default Autocomplete;