import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import { useRef, useState, useMemo, useCallback, useEffect } from 'react';
import { useDebounce } from '../../hooks/use-debounce';
import { escapeRegExp } from '../../utils/functions';
export function useAutocomplete(props) {
  var value = props.value,
    multiple = props.multiple,
    _props$options = props.options,
    options = _props$options === void 0 ? [] : _props$options,
    _props$sortAlphabetic = props.sortAlphabetically,
    sortAlphabetically = _props$sortAlphabetic === void 0 ? false : _props$sortAlphabetic,
    getOptionLabel = props.getOptionLabel,
    getOptionValue = props.getOptionValue,
    onOpen = props.onOpen,
    onChange = props.onChange,
    onClose = props.onClose,
    submitOnBlur = props.submitOnBlur,
    getOptionDisabled = props.getOptionDisabled,
    groupBy = props.groupBy,
    _props$closeMenuAfter = props.closeMenuAfterSelection,
    closeMenuAfterSelection = _props$closeMenuAfter === void 0 ? true : _props$closeMenuAfter,
    setMenuJustOpened = props.setMenuJustOpened;
  var _useState = useState(undefined),
    _useState2 = _slicedToArray(_useState, 2),
    anchorEl = _useState2[0],
    setAnchorEl = _useState2[1];
  var _useState3 = useState(''),
    _useState4 = _slicedToArray(_useState3, 2),
    searchTerm = _useState4[0],
    setSearchTerm = _useState4[1];
  var _useState5 = useState(false),
    _useState6 = _slicedToArray(_useState5, 2),
    isSearchMode = _useState6[0],
    setIsSearchMode = _useState6[1];
  var _useState7 = useState(-1),
    _useState8 = _slicedToArray(_useState7, 2),
    focusedMenuItemIndex = _useState8[0],
    setFocusedMenuItemIndex = _useState8[1];
  var inputRef = useRef(null);
  var open = Boolean(anchorEl);
  var debouncedSearchTerm = useDebounce(searchTerm, 300);
  var formattedValue = useMemo(function () {
    if (multiple) {
      return _toConsumableArray(new Set(Array.isArray(value) ? value : [])); // Format + remove duplications
    }
    return (Array.isArray(value) ? '' : value) || '';
  }, [multiple, value]);
  var isMultiple = Boolean(multiple) && Array.isArray(formattedValue);
  var isValueSelected = isMultiple ? formattedValue.length > 0 : Boolean(formattedValue);
  var optionsList = useMemo(function () {
    var nextFilteredOptions = _toConsumableArray(options || []);
    if (sortAlphabetically) {
      return nextFilteredOptions.sort(function (a, b) {
        return getOptionLabel(a).localeCompare(getOptionLabel(b));
      });
    }
    return nextFilteredOptions;
  }, [options, sortAlphabetically]);
  var getOptionById = useCallback(function (optionId) {
    return optionsList.find(function (option) {
      return getOptionValue(option) === optionId;
    });
  }, [optionsList]);
  var inputValue = useMemo(function () {
    // When there is searchTerm we should show it in Input
    if (isSearchMode) {
      return searchTerm;
    }
    // If value is array it's shown tags in Input area, hance no need to return anything here so we send empty string
    if (Array.isArray(formattedValue)) {
      return '';
    }
    var selectedOption = getOptionById(formattedValue);
    return selectedOption ? getOptionLabel(selectedOption) : '';
  }, [searchTerm, optionsList, formattedValue, isSearchMode]);
  var checkIsIdSelected = useCallback(function (optionId) {
    return isMultiple ? formattedValue.includes(optionId) : formattedValue === optionId;
  }, [isMultiple, formattedValue]);
  var filteredOptions = useMemo(function () {
    return debouncedSearchTerm ? optionsList.filter(function (option) {
      return new RegExp(escapeRegExp(debouncedSearchTerm), 'i').test(getOptionLabel(option));
    }) : optionsList;
  }, [optionsList, debouncedSearchTerm]);
  var groupedFilteredOptions = useMemo(function () {
    if (groupBy) {
      var groupedMap = filteredOptions.reduce(function (accumMap, option) {
        var _accumMap$get;
        var key = groupBy(option);
        if (!accumMap.has(key)) {
          accumMap.set(key, {
            options: [],
            groupedByValue: key
          });
        }
        (_accumMap$get = accumMap.get(key)) === null || _accumMap$get === void 0 || (_accumMap$get = _accumMap$get.options) === null || _accumMap$get === void 0 || _accumMap$get.push(option);
        return accumMap;
      }, new Map());
      return _toConsumableArray(groupedMap).map(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
          group = _ref2[1];
        return group;
      });
    }
    return [{
      options: filteredOptions
    }];
  }, [filteredOptions, groupBy]);
  var handleOpenMenuClick = function handleOpenMenuClick(event) {
    setAnchorEl(inputRef.current);
    if (onOpen) {
      onOpen(event);
    }
  };
  var handleCloseMenuClick = function handleCloseMenuClick(event) {
    setAnchorEl(undefined);
    setIsSearchMode(false);
    setFocusedMenuItemIndex(-1);
    if (onClose) {
      onClose(event);
    }
  };
  var handleMenuItemClick = function handleMenuItemClick(option) {
    if (typeof onChange === 'function' && !getOptionDisabled(option)) {
      var id = getOptionValue(option);
      var newValue = id;
      if (isMultiple) {
        var newValueSet = new Set(formattedValue);
        newValueSet[newValueSet.has(id) ? 'delete' : 'add'](id);
        newValue = _toConsumableArray(newValueSet);
      }
      onChange(newValue);
      if (!isMultiple || closeMenuAfterSelection) {
        handleCloseMenuClick();
      } else {
        setIsSearchMode(false);
      }
    }
  };
  var handleChangeSearchTerm = function handleChangeSearchTerm(event) {
    setSearchTerm(event.currentTarget.value);
    setAnchorEl(inputRef.current);
    setIsSearchMode(true);
  };
  var handleOnBlur = function handleOnBlur() {
    if (submitOnBlur) {
      submitOnBlur();
    }
    setIsSearchMode(false);
    setAnchorEl(undefined);
  };
  var handleOnRemoveItem = function handleOnRemoveItem(event, optionId) {
    event.stopPropagation();
    if (isMultiple && onChange) {
      var newValueSet = new Set(formattedValue);
      newValueSet[newValueSet.has(optionId) ? 'delete' : 'add'](optionId);
      onChange(_toConsumableArray(newValueSet));
    }
    handleOnBlur();
  };
  var handleKeyDown = function handleKeyDown(event) {
    // When menu is open we handle select with arrow keys
    if (open) {
      if (event.key === 'ArrowDown') {
        var nextIndex = focusedMenuItemIndex + 1;
        setFocusedMenuItemIndex(nextIndex >= filteredOptions.length ? 0 : nextIndex);
        setMenuJustOpened(false);
      } else if (event.key === 'ArrowUp') {
        var prevIndex = focusedMenuItemIndex - 1;
        setFocusedMenuItemIndex(prevIndex < 0 ? filteredOptions.length - 1 : prevIndex);
        setMenuJustOpened(false);
      } else if (event.key === 'Enter' && focusedMenuItemIndex >= 0) {
        var option = filteredOptions[focusedMenuItemIndex];
        handleMenuItemClick(option);
      } else if (event.key === 'Escape') {
        handleCloseMenuClick(event);
      }
    }
  };
  var handleClearIconClick = function handleClearIconClick() {
    if (onChange) {
      onChange(isMultiple ? [] : '');
    }
  };
  var handleSelectAllOptions = function handleSelectAllOptions() {
    if (isMultiple && onChange) {
      var allOptionIds = optionsList.reduce(function (acc, option) {
        if (!getOptionDisabled(option)) {
          acc.push(getOptionValue(option));
        }
        return acc;
      }, []);
      onChange(_toConsumableArray(allOptionIds));
    }
  };
  useEffect(function () {
    if (!isSearchMode) {
      setSearchTerm('');
    }
  }, [isSearchMode]);
  useEffect(function () {
    if (open) {
      // If multiple, set setFocusedMenuItemIndex to the last selected value's index
      if (isMultiple) {
        var lastSelectedIndex = -1;
        formattedValue.forEach(function (value) {
          var index = filteredOptions.findIndex(function (option) {
            return getOptionValue(option) === value;
          });
          if (index !== -1) {
            lastSelectedIndex = index;
          }
        });
        setFocusedMenuItemIndex(lastSelectedIndex >= 0 ? lastSelectedIndex : -1);
      } else {
        // If single, set setFocusedMenuItemIndex to the selected value's index
        var selectedIndex = filteredOptions.findIndex(function (option) {
          return getOptionValue(option) === formattedValue;
        });
        setFocusedMenuItemIndex(selectedIndex >= 0 ? selectedIndex : -1);
      }
    }
  }, [open, formattedValue, filteredOptions, multiple, getOptionValue]);
  return {
    formattedValue: formattedValue,
    filteredOptions: filteredOptions,
    groupedFilteredOptions: groupedFilteredOptions,
    optionsList: optionsList,
    inputRef: inputRef,
    inputValue: inputValue,
    isValueSelected: isValueSelected,
    open: open,
    anchorEl: anchorEl,
    searchTerm: searchTerm,
    handleMenuItemClick: handleMenuItemClick,
    handleOpenMenuClick: handleOpenMenuClick,
    handleChangeSearchTerm: handleChangeSearchTerm,
    handleCloseMenuClick: handleCloseMenuClick,
    checkIsIdSelected: checkIsIdSelected,
    getOptionById: getOptionById,
    handleOnRemoveItem: handleOnRemoveItem,
    handleOnBlur: handleOnBlur,
    handleKeyDown: handleKeyDown,
    handleClearIconClick: handleClearIconClick,
    handleSelectAllOptions: handleSelectAllOptions,
    focusedMenuItemIndex: focusedMenuItemIndex,
    setMenuJustOpened: setMenuJustOpened
  };
}