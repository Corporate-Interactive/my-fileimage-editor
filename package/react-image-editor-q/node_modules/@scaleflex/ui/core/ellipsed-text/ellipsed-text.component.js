import _extends from "@babel/runtime/helpers/extends";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
var _excluded = ["children", "element", "maxLinesCount", "customMaxHeight", "noTooltip", "tooltipProps", "textWrapperProps"];
import React, { useState, useRef, useLayoutEffect, useCallback } from 'react';
import TooltipV2 from '../tooltip-v2';
import { ignoreEvent, intrinsicComponent } from '../../utils/functions';
import Styled from './ellipsed-text.styles';
var POSSIBLE_FONT_GAP = 1; // there is a possibility that the font might render around ~1px in height/width for some chars so we are considering that 1px in-case.

var EllipsedText = intrinsicComponent(function (_ref, ref) {
  var children = _ref.children,
    _ref$element = _ref.element,
    element = _ref$element === void 0 ? 'div' : _ref$element,
    _ref$maxLinesCount = _ref.maxLinesCount,
    maxLinesCount = _ref$maxLinesCount === void 0 ? 2 : _ref$maxLinesCount,
    customMaxHeight = _ref.customMaxHeight,
    _ref$noTooltip = _ref.noTooltip,
    noTooltip = _ref$noTooltip === void 0 ? false : _ref$noTooltip,
    tooltipProps = _ref.tooltipProps,
    _ref$textWrapperProps = _ref.textWrapperProps,
    textWrapperProps = _ref$textWrapperProps === void 0 ? {} : _ref$textWrapperProps,
    rest = _objectWithoutProperties(_ref, _excluded);
  var textContentRef = useRef(null);
  var _useState = useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    shouldEllipse = _useState2[0],
    setShouldEllipse = _useState2[1];
  var applyEllipsisIfNeeded = useCallback(function (elem) {
    if (!elem || !maxLinesCount) {
      return;
    }
    var elemScrollHeight = elem.scrollHeight;
    var elemScrollWidth = elem.scrollWidth;
    var elemHeight = elem.clientHeight + POSSIBLE_FONT_GAP || elemScrollHeight;
    var elemWidth = elem.clientWidth + POSSIBLE_FONT_GAP || elemScrollWidth;
    setShouldEllipse(elemScrollHeight > elemHeight || elemScrollWidth > elemWidth);
  }, [maxLinesCount, customMaxHeight]);
  var renderTooltipTitle = function renderTooltipTitle() {
    return /*#__PURE__*/React.createElement("div", {
      onClick: ignoreEvent,
      onDoubleClick: ignoreEvent
    }, children);
  };
  useLayoutEffect(function () {
    if (textContentRef.current) {
      applyEllipsisIfNeeded(textContentRef.current);
    }
  }, [element, maxLinesCount, customMaxHeight]);
  useLayoutEffect(function () {
    var applyOnElemResize = function applyOnElemResize() {
      if (textContentRef.current) {
        applyEllipsisIfNeeded(textContentRef.current);
      }
    };
    var resizeObserver = new ResizeObserver(applyOnElemResize);
    if (textContentRef.current) {
      resizeObserver.observe(textContentRef.current);
    }
    return function () {
      resizeObserver.disconnect();
    };
  }, []);
  return /*#__PURE__*/React.createElement(Styled.EllipsedTextWrapper, _extends({
    $maxLinesCount: maxLinesCount,
    ref: textContentRef
  }, textWrapperProps, rest), shouldEllipse && !noTooltip ? /*#__PURE__*/React.createElement(TooltipV2, _extends({
    position: "top",
    size: "md",
    ref: ref,
    arrow: true
  }, tooltipProps, {
    title: renderTooltipTitle()
  }), /*#__PURE__*/React.createElement(Styled.TooltipContent, {
    as: element,
    $customMaxHeight: customMaxHeight
  }, children)) : children);
});
export default EllipsedText;